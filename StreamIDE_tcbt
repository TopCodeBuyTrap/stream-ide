INSTALL
# ---------------------------- Atualiza o gerenciador de pacotes, setuptools e wheel:
python.exe -m pip install --upgrade pip
python -m pip install --upgrade setuptools wheel

# ---------------------------- Criar app para executavel em pc:
pip install streamlit-desktop-app   version: 0.3.3
home-page: https://github.com/ohtaman/streamlit-desktop-app

# ---------------------------- Editor de Codigos
pip install streamlit_ace   Version: 0.1.1
Home-page: https://share.streamlit.io/okld/streamlit-gallery/main?p=ace-editor

# ---------------------------- Rodar
streamlit run app_.py

# ----------------------------Para criar o executavel:
streamlit-desktop-app build APP_.py `
  --name Stream_IDE `
  --streamlit-options --theme.base=dark `
  --pyinstaller-options `
    --onedir --noconsole --noconfirm `

# ----------------------------  Stream-IDE / StreamIDE
GitHub: https://github.com/TopCodeBuyTrap/stream-ide
Youtube: https://youtu.be/w04XjMlDvGA

# Arquivos---- :
|-- APP_.py ----:
Este arquivo √© o c√©rebro da aplica√ß√£o. Ele n√£o implementa funcionalidades isoladas, mas coordena todas elas. √â respons√°vel por fluxo, estado, navega√ß√£o, persist√™ncia e integra√ß√£o entre m√≥dulos. Qualquer falha aqui compromete toda a IDE.

# Adicione este bloco NO IN√çCIO do seu arquivo APP_.py e outros arquivos principais
# Isso corrige o erro "ModuleNotFoundError" quando roda o execut√°vel

import sys
import os
from pathlib import Path

# Detecta se est√° rodando como execut√°vel (frozen) ou script python normal
if getattr(sys, 'frozen', False):
    # Se for execut√°vel, a pasta raiz √© onde est√° o .exe
    app_root = Path(sys.executable).parent.absolute()

    # Adiciona a pasta _internal ao caminho de busca do Python
    sys.path.append(str(app_root / "_internal"))
    sys.path.append(str(app_root))
else:
    # Se for script normal
    app_root = Path(__file__).parent.absolute()
    sys.path.append(str(app_root))


#-----------------------------------------------------------------------------------

def select_arquivo_recente(col2):
    st.sidebar.image('.arquivos/logo_.png',width=100)


    registros = ler_A_CONTROLE_PROJETOS()
    if not registros:
        return None, None, None

    # registros =
    # (DIRETORIO_TRABALHANDO, VERSION, DATA, DIRETORIOS, ARQUIVOS, OBS)
    ordenar_por = st.selectbox(
        "Ordenar por:",
        ["√öltimo usado", "Data", "Vers√£o", "Ordem alfab√©tica (agrupado)"],
        key="ordenacao_recente",label_visibility='collapsed'
    )

    dados = []
    for r in registros:
        caminho, versao, data = r[0], r[1], r[2]
        dados.append({
            "caminho": caminho,
            "nome": os.path.basename(caminho),
            "versao": versao,
            "data": data
        })

    if ordenar_por == "√öltimo usado":
        dados = sorted(
            dados,
            key=lambda x: x["data"] or "",
            reverse=True
        )

    elif ordenar_por == "Data":
        dados = sorted(
            dados,
            key=lambda x: datetime.fromisoformat(x["data"]) if x["data"] else datetime.min,
            reverse=True
        )

    elif ordenar_por == "Vers√£o":
        dados = sorted(
            dados,
            key=lambda x: (x["versao"] or "").lower()
        )

    elif ordenar_por == "Ordem alfab√©tica (agrupado)":
        grupos = {}
        for d in dados:
            grupos.setdefault(d["nome"], []).append(d)

        dados = []
        for nome in sorted(grupos.keys(), key=str.lower):
            grupo = sorted(
                grupos[nome],
                key=lambda x: datetime.fromisoformat(x["data"]) if x["data"] else datetime.min
            )
            dados.extend(grupo)

    if "projeto_idx" not in st.session_state:
        st.session_state.projeto_idx = 0
        st.toast("sele√ß√£o inicial definida".title())

    selecionado = st.selectbox(
        "Projetos recentes",
        options=range(len(dados)),
        format_func=lambda i: dados[i]["nome"],
        key="projeto_idx",label_visibility='collapsed'
    )

    if "ultimo_idx" not in st.session_state:
        st.session_state.ultimo_idx = selecionado

    if selecionado != st.session_state.ultimo_idx:
        st.toast("projeto trocado".title())
        st.session_state.ultimo_idx = selecionado

    item = dados[selecionado]
    if st.button(f'Acesar',use_container_width=True):
        data = contar_estrutura(item["caminho"])
        versao_set = data["versoes"][0]
        esc_A_CONTROLE_PROJETOS(str(item["caminho"]), list(versao_set)[0], data_sistema(), data["pastas"], data["arquivos"] , '')


def app():
    # =====================================================
    # COLOQUE ISSO NO **IN√çCIO** do seu app(), ANTES de tudo:

    # =====================================================

    global arquivo_selecionado_caminho, arquivo_selecionado_nome, arquivo_selecionado_conteudo
    try:
        pjt = ler_A_CONTROLE_PROJETOS()[-1]
        caminho = pjt[0]
        versao = pjt[1]
        data = pjt[2]

        if se_B_ARQUIVOS_RECENTES(caminho) == False:
            Del_B_ARQUIVOS_RECENTES()
            esc_B_ARQUIVOS_RECENTES(Path(caminho), str(contar_estrutura(caminho)))
    except IndexError: pass

    if len(ler_B_ARQUIVOS_RECENTES()) == 0:
        st.button('Entar')
        from APP_Menus import Cria_Projeto_pouppap
        footer_container = st.container(border=True)
        with footer_container:
            st.write('Seja Bem Vindo Ordinario/a !')
            st.image(IMAGEM_LOGO)
        Cria_Projeto_pouppap(st)

    else:



        with st.container(border=True, key='MenuTopo'):
            Top1,Top2 ,Top3 ,Top4,Top5,Top6,Top7,Top8= st.columns([.4,.4,.4,.4,2,1.4,.8,1])

        with Top7:
            from APP_Atualizador import checar_atualizacao
            checar_atualizacao(Top7)

        with Top6:
            Ttp1,Ttp2 = st.columns(2) # Bot√£o de run e stop

        with Top3:
            Trm1,Trm2 = st.columns([2,8])
            Trm1.write(':material/terminal:')

        with Top4:
            Prw1, Prw2 = st.columns([2, 8])
            Prw1.write(':material/directions_bike:')

        from APP_Menus import Abrir_Menu
        #Abrir_Menu(st)
        # ============================================================= MENU SUPERIOR
        if Top2.button(":material/refresh:",icon='‚ôªÔ∏è',help='limpar os caches do app'.title()):
            limpar_CASH()
        st.markdown('<style>' + open('./style.css').read() + '</style>', unsafe_allow_html=True)

        #--------------------------------------------------------------------- MENUS DE EDI√á√ÉO E CRIA√á√ÉO DE ARQUIVOS
        from  APP_Menus import  Abrir_Menu,Custom
        Pasta_Executavel = _DIRETORIO_EXECUTAVEL_()
        Pasta_Todos_Projetos = _DIRETORIO_PROJETOS_()
        Pasta_Projeto_Atual = caminho
        Meus_Arquivos = listar_arquivos_e_pastas(Pasta_Projeto_Atual)

        # Exemplo de uso
        with Top1:
            btnt = Button_Nao_Fecha(':material/folder_open:'+":material/keyboard_double_arrow_left:",
            ':material/folder:' + ':material/keyboard_double_arrow_right:', key="botao_diretorio")
        if btnt:
            col1, col2 = st.columns([1.2, 7])
            vl = 400
            with col1.container(border=True, width=vl,key='menu_lado_sidebar',height=800):
                # :material/settings:  :material/emoji_symbols:
                Abrir_Menu(st)

                select_arquivo_recente(st)

                if NOME_CUSTOM != 'Padr√£o':
                    btcst = Button_Nao_Fecha(f'**{NOME_CUSTOM}** - :material/build:' + ":material/keyboard_double_arrow_up:",
                                            f"**{NOME_CUSTOM}** - :material/build:" + ':material/keyboard_double_arrow_down:',
                                            key="bBotao_recustomizar")
                    if btcst:
                        Customization(st,NOME_CUSTOM)
        else:
            col1, col2 = st.columns([.2, 9])
        #------------------z--------------------------------------------------- SIDIBAR LATERAL
        with st.sidebar:
            caminho_completo = Pasta_Projeto_Atual  # Ex: "C:\\Users\\henri\\PycharmProjects\\IDE_TOP"
            unidade = os.path.splitdrive(caminho_completo)[0]  # Ex: "C:"
            nome_pasta = os.path.basename(caminho_completo)
            Arq_Selec_Nomes, Arq_Selec_Diretorios = Sidebar_Diretorios(st, Meus_Arquivos, 7)

        if Top8.button(f':material/search: {os.path.join(nome_pasta)}',use_container_width=True, type="secondary"):
            Open_Explorer(Pasta_Projeto_Atual)


        if len(Arq_Selec_Diretorios) > 0:
            from APP_Editor_Run_Preview import Editor_Simples

            try:
                with col2:
                    arquivos_abertos_nomes, arquivos_abertos_caminhos, arquivo_selecionado_nome, arquivo_selecionado_caminho,arquivo_selecionado_conteudo\
                    = Editor_Simples(col1,Prw2,Top5,Arq_Selec_Diretorios,THEMA_EDITOR, EDITOR_TAM_MENU,Ttp2,Ttp1,)
            except UnicodeDecodeError:
                st.warning('Arquivo n√£o Reconhecido GmeOver!')



            Tab1, Tab2 = st.columns([.4, 9])
            val = ''
            with Tab2.container(border=True, key='Terminal_cmd', width=900):
                with Trm2:
                    altura_term = st.slider( ':material/terminal:', value=300, min_value=200, max_value=800, step=300,label_visibility='collapsed')
                with st.expander(f":material/terminal: Terminal: {val}"):
                    Terminal(altura_term,THEMA_TERMINAL, TERMINAL_TAM_MENU)

            # --------------------------------------------------------------------- BUSCAR ARQUIVO SELECIONADO
            if arquivo_selecionado_caminho and os.path.isfile(arquivo_selecionado_caminho):
                caminho = Path(arquivo_selecionado_caminho)
                nome_sem_extensao = caminho.stem
                extensao_arquivo = caminho.suffix
                nome_arquivo = caminho.name

                # Se for imagem, mostra no container
                if extensao_arquivo.lower() in ('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp'):
                    footer_container = Tab2.container(border=True, key="meu_container_unico")
                    with footer_container:
                        st.image(caminho, caption=f"üñºÔ∏è {caminho.name}")


#---------------------------
if __name__ == "__main__":
    try:
        import streamlit as st
        from datetime import datetime

        from APP_SUB_Customizar import Customization
        from APP_SUB_Funcitons import Identificar_linguagem, escreve, chec_se_arq_do_projeto, contar_estrutura, \
            Button_Nao_Fecha, data_sistema, resumo_pasta, limpar_CASH, Linha_Sep
        from APP_SUB_Janela_Explorer import listar_arquivos_e_pastas, Open_Explorer, Abrir_Arquivo_Select_Tabs
        from APP_Sidebar import Sidebar_Diretorios
        from Banco_dados import ler_A_CONTROLE_PROJETOS, ler_B_ARQUIVOS_RECENTES, ATUAL_B_ARQUIVOS_RECENTES, \
            se_B_ARQUIVOS_RECENTES, esc_B_ARQUIVOS_RECENTES, Del_B_ARQUIVOS_RECENTES, ler_A_CONTROLE_ABSOLUTO, \
            Del_A_CONTROLE_ABSOLUTO, Del_CUSTOMIZATION, esc_A_CONTROLE_PROJETOS
        from APP_SUB_Controle_Driretorios import _DIRETORIO_EXECUTAVEL_, _DIRETORIO_PROJETOS_, _DIRETORIO_PROJETO_ATUAL_

        import os
        from pathlib import Path
        from APP_Terminal import Terminal
        st.set_page_config(page_title="Stream-IDE", layout="wide")

        if 'config_absoluta_ok' not in st.session_state:
            st.session_state.config_absoluta_ok = False

        # üîπ SE J√Å TEM CONFIG ‚Üí ENTRA DIRETO NA IDE
        if len(ler_A_CONTROLE_ABSOLUTO()) > 0 or st.session_state.config_absoluta_ok:
            from APP_Htmls import Carregamento_BancoDados_Temas
            (IMAGEM_LOGO, NOME_CUSTOM, NOME_USUARIO, COR_CAMPO, COR_MENU, THEMA_EDITOR, EDITOR_TAM_MENU,THEMA_PREVIEW,PREVIEW_TAM_MENU,
             THEMA_TERMINAL,TERMINAL_TAM_MENU,TOP_CAB,FONTE_MENU,FONTE_CAMPO) = Carregamento_BancoDados_Temas(st)

            app( )

        # üîπ SEN√ÉO ‚Üí MOSTRA ABERTURA
        else:
            from Abertura_TCBT import Abertura
            Del_CUSTOMIZATION()

            if Abertura() == True:
                st.rerun()
    except Exception as e:
        st.error(f"üö® ERRO: {e}")
        st.warning("üîÑ **FECHE e REABRA o programa**")


|-- Abertura_TCBT.py ----:
Este arquivo √© um BLOQUEIO DE SEGURAN√áA do sistema. Sem ele, a IDE poderia iniciar sem diret√≥rios v√°lidos, sem banco configurado e sem temas. Ele garante que o ambiente esteja 100% consistente antes de liberar qualquer funcionalidade de edi√ß√£o ou execu√ß√£o.

|-- APP_Menus.py ----:
Este arquivo √©: ‚Äì controlador de menus ‚Äì orquestrador de fluxos ‚Äì integrador UI ‚Üî sistema ‚Üî banco
Ele n√£o renderiza o editor, mas controla tudo que acontece ao redor dele. √â o c√©rebro operacional da IDE.

|-- APP_Htmls.py ----:
Este arquivo n√£o √© apenas est√©tico.
Ele controla:
Identidade visual
Experi√™ncia do usu√°rio
Organiza√ß√£o de layout
Performance (cache)
Integra√ß√£o entre banco, estado e UI
Qualquer mudan√ßa aqui impacta diretamente toda a aplica√ß√£o Streamlit.
√â um arquivo cr√≠tico e estrutural do projeto.

|-- APP_Atualizador.py ----:
APP_Atualizador.py
Este arquivo implementa o mecanismo completo de autoatualiza√ß√£o da aplica√ß√£o quando distribu√≠da tanto como c√≥digo-fonte quanto como execut√°vel empacotado (PyInstaller).

Fun√ß√£o checar_atualizacao(Coluna):
Respons√°vel por verificar se existe uma vers√£o mais recente dispon√≠vel no reposit√≥rio GitHub.
‚Äì L√™ a vers√£o local persistida no banco usando ultima_versao().
‚Äì Consulta o arquivo LATEST_VERSION.txt no GitHub com cache-busting via timestamp.
‚Äì Desativa verifica√ß√£o SSL para evitar falhas em execut√°veis PyInstaller.
‚Äì Compara vers√µes como string.
‚Äì Se houver vers√£o nova, exibe notifica√ß√£o e bot√£o de atualiza√ß√£o na coluna recebida.
‚Äì Se estiver atualizado, informa sucesso.
‚Äì Em caso de falha de rede ou exce√ß√£o, exibe erro t√©cnico.

Fun√ß√£o atualizar_tudo(nova_versao):
Executa o processo completo de atualiza√ß√£o da aplica√ß√£o.

Etapa 1 ‚Äì Persist√™ncia:
Salva a nova vers√£o no banco de dados antes da atualiza√ß√£o f√≠sica, garantindo consist√™ncia de estado.

Etapa 2 ‚Äì Download:
Baixa o ZIP do branch main do reposit√≥rio GitHub e grava como update.zip no diret√≥rio raiz da aplica√ß√£o.

Etapa 3 ‚Äì Extra√ß√£o:
Extrai o conte√∫do do ZIP em um diret√≥rio tempor√°rio (temp_update).

Etapa 4 ‚Äì Limpeza controlada:
Remove o diret√≥rio _internal antigo, com tentativas repetidas para contornar bloqueios de arquivo comuns em Windows.

Etapa 5 ‚Äì Substitui√ß√£o de c√≥digo:
Copia recursivamente todos os arquivos do reposit√≥rio extra√≠do para o diret√≥rio _internal, preservando estrutura e metadados. Esse diret√≥rio representa o n√∫cleo execut√°vel da IDE.

Etapa 6 ‚Äì Arquivos especiais:
Copia style.css para a raiz da aplica√ß√£o quando presente, garantindo consist√™ncia visual ap√≥s a atualiza√ß√£o.

Etapa 7 ‚Äì Finaliza√ß√£o:
Remove arquivos tempor√°rios, exibe feedback visual no sidebar, solicita rein√≠cio manual da aplica√ß√£o e encerra o processo com sys.exit(0).

Papel arquitetural:
Este m√≥dulo √© o atualizador oficial da IDE. Ele permite distribui√ß√£o cont√≠nua sem reinstala√ß√£o, centraliza controle de vers√£o, resolve diferen√ßas entre execu√ß√£o empacotada e em desenvolvimento, e protege a integridade do ambiente do usu√°rio durante upgrades.

|-- APP_Sidebar.py ----:
Ele √© o n√∫cleo de navega√ß√£o da IDE
‚Äì Unifica √°rvore f√≠sica do projeto + arquivos persistidos no banco
‚Äì Controla estado visual complexo (pastas abertas, arquivos ativos, origem)
‚Äì Resolve duplica√ß√£o, sincroniza√ß√£o e descarte de arquivos
‚Äì Tem duas implementa√ß√µes: uma com pills e outra com checkbox
‚Äì √â fundamental para manter coer√™ncia entre UI, filesystem e banco

|-- APP_Editor_Run_Preview.py ----:
Este arquivo √© o cora√ß√£o funcional da IDE. Ele integra edi√ß√£o, execu√ß√£o, I/O interativo e visualiza√ß√£o de sa√≠da em um √∫nico fluxo cont√≠nuo, simulando o comportamento de uma IDE desktop dentro das limita√ß√µes do Streamlit.

|-- APP_Terminal.py ----:
Este arquivo implementa um terminal PowerShell realista e funcional, com execu√ß√£o ass√≠ncrona, suporte a virtualenv, m√∫ltiplas abas e streaming de sa√≠da. Ele elimina a necessidade de terminal externo e fecha o ciclo de IDE completo (editor + run + terminal do sistema) dentro do Streamlit.

|-- APP_SUB_Controle_Driretorios.py ----:
O arquivo APP_SUB_Controle_Driretorios.py centraliza a resolu√ß√£o dos diret√≥rios
principais da aplica√ß√£o, fornecendo fun√ß√µes que retornam o caminho do execut√°vel,
da pasta de projetos e do projeto atualmente ativo, com base em informa√ß√µes
armazenadas no banco de dados, usando um fallback seguro quando n√£o h√° projeto
selecionado.

|-- APP_SUB_Customizar.py ----:
O arquivo APP_SUB_Customizar.py implementa a tela de configura√ß√µes da aplica√ß√£o.
Ele l√™ do banco as prefer√™ncias visuais do usu√°rio (tamanhos, fontes, cores e
temas), exibe essas op√ß√µes em formul√°rios do Streamlit e salva as altera√ß√µes
quando o usu√°rio confirma, aplicando-as imediatamente √† interface da IDE.

|-- APP_SUB_Funcitons.py ----:
O arquivo APP_SUB_Funcitons.py re√∫ne fun√ß√µes utilit√°rias centrais da IDE, cobrindo an√°lise de c√≥digo, apoio visual ao editor, m√©tricas de qualidade, manipula√ß√£o de arquivos e leitura da estrutura do projeto.

Ele faz, em resumo:
‚Äì analisa c√≥digo Python via AST para gerar anota√ß√µes, alertas e marcadores no editor
‚Äì calcula um score de qualidade do c√≥digo para uso em dashboard
‚Äì identifica linguagem por extens√£o e cria arquivos de texto
‚Äì percorre a pasta do projeto para mapear estrutura, estat√≠sticas e ambientes Python
‚Äì sincroniza a √°rvore do projeto em um JSON interno
‚Äì fornece fun√ß√µes auxiliares de UI (alertas, bot√µes persistentes, separadores)
‚Äì gerencia √≠cones de arquivos, nomes √∫nicos e valida se arquivos pertencem ao projeto

√â o arquivo de apoio funcional que sustenta editor, navegador de arquivos,
dashboard e valida√ß√µes internas da aplica√ß√£o.

|-- APP_SUB_Janela_Explorer.py ----:
O arquivo APP_SUB_Janela_Explorer.py implementa o explorador de arquivos e
pastas da IDE, respons√°vel por navega√ß√£o, sele√ß√£o e manipula√ß√£o b√°sica do
filesystem dentro da interface Streamlit.

Ele faz, de forma objetiva:
‚Äì lista pastas e arquivos sem sair do diret√≥rio atual
‚Äì permite navegar entre diret√≥rios, voltar, pesquisar por nome e abrir caminhos
‚Äì mant√©m o estado de pastas abertas e arquivos selecionados via session_state
‚Äì permite criar novas pastas pelo painel
‚Äì abre arquivos para leitura, apaga arquivos e abre a pasta no Explorer do
Windows
‚Äì fornece uma janela de sele√ß√£o reutiliz√°vel para arquivos ou pastas
‚Äì inclui utilidades auxiliares (IDs seguros, download de imagem, detec√ß√£o de
instala√ß√µes Python no Windows)

|-- Banco_dados.py ----:
O m√≥dulo Banco_dados.py √© respons√°vel por toda a camada de acesso a dados do
sistema. Ele utiliza SQLite como mecanismo de persist√™ncia local e centraliza
configura√ß√µes globais, hist√≥rico de projetos, estado atual de execu√ß√£o, controle
de arquivos abertos e personaliza√ß√£o da interface.

Arquiteturalmente, este m√≥dulo funciona como a ‚Äúfonte √∫nica da verdade‚Äù da
aplica√ß√£o. Nenhum outro script mant√©m estado cr√≠tico em mem√≥ria de forma
definitiva; tudo que precisa persistir ou ser compartilhado entre m√≥dulos passa
por este banco.

A inicializa√ß√£o √© autom√°tica. A fun√ß√£o init_db() cria todas as tabelas
necess√°rias caso ainda n√£o existam, garantindo que o sistema sempre inicie em um
estado v√°lido, mesmo na primeira execu√ß√£o.

A tabela A_CONTROLE_ABSOLUTO armazena as configura√ß√µes globais do sistema.
Ela define onde o programa est√° instalado, onde os projetos ficam armazenados,
diret√≥rios de backup, integra√ß√£o com Ollama, vers√£o do modelo, al√©m de campos
reservados para credenciais de IA externa. Esse registro representa o ‚Äúambiente
base‚Äù da aplica√ß√£o.

A tabela A_CONTROLE_PROJETOS registra o hist√≥rico e os metadados dos
projetos. Cada projeto aberto ou criado √© persistido com informa√ß√µes como
diret√≥rio de trabalho, vers√£o do ambiente, data, quantidade de pastas, arquivos
e observa√ß√µes. Ela n√£o representa o projeto ativo, mas sim o cat√°logo de
projetos conhecidos pelo sistema.

A tabela B_ARQUIVOS_RECENTES √© o elemento central de estado operacional.
Ela representa qual projeto est√° ativo no momento. Esse design evita depend√™ncia
de vari√°veis globais ou passagem direta de estado entre m√≥dulos, o que √©
especialmente relevante em aplica√ß√µes Streamlit. Normalmente existe apenas um
registro relevante nessa tabela, que √© substitu√≠do quando o projeto ativo muda.

A tabela CONTROLE_ARQUIVOS mant√©m o controle de arquivos abertos ou
carregados, inclusive arquivos externos ao projeto atual. Ela permite armazenar
conte√∫do, caminho absoluto e extens√£o, viabilizando leitura, edi√ß√£o e reaproveito
sem depender constantemente do sistema de arquivos.

A tabela CUSTOMIZATION concentra toda a personaliza√ß√£o visual e funcional
do usu√°rio. Ela define temas, fontes, cores, tamanhos, bordas, op√ß√µes visuais,
logo e prefer√™ncias gerais. Apenas um perfil permanece ativo por vez, controlado
pela coluna OBS, o que simplifica a aplica√ß√£o de estilos globais.

As fun√ß√µes do m√≥dulo seguem um padr√£o consistente:
‚Äì esc_* para escrita ou inser√ß√£o
‚Äì ler_* para leitura
‚Äì Del_* para exclus√£o
‚Äì ATUAL_* para atualiza√ß√£o incremental ou direta
‚Äì se_* para verifica√ß√µes de exist√™ncia ou condi√ß√£o

Esse padr√£o torna o c√≥digo previs√≠vel, facilita manuten√ß√£o e reduz erros de uso.

Em termos de arquitetura, o banco separa claramente:
‚Äì configura√ß√£o global
‚Äì hist√≥rico de projetos
‚Äì estado atual de execu√ß√£o
‚Äì arquivos em uso
‚Äì perfil de interface

Essa separa√ß√£o reduz acoplamento entre m√≥dulos, melhora escalabilidade e permite
que novos recursos sejam adicionados sem reestrutura√ß√£o profunda.

Este m√≥dulo √©, portanto, a base estrutural do sistema. Qualquer falha ou mudan√ßa
aqui impacta toda a aplica√ß√£o, o que justifica a centraliza√ß√£o, o controle de
concorr√™ncia simples e o uso consistente de transa√ß√µes.

|-- Banco_Predefinitions.py ----:
Este m√≥dulo √© respons√°vel por armazenar e recuperar dados pr√©-definidos do
sistema, separados do banco principal. Ele funciona como um reposit√≥rio de
configura√ß√µes reutiliz√°veis, layouts e vers√µes da aplica√ß√£o.

O arquivo cria e gerencia um banco SQLite independente
(Base_Dados_PreDefinidos.db), usado para persistir informa√ß√µes que n√£o pertencem
ao estado din√¢mico do projeto, mas sim a predefini√ß√µes estruturais e hist√≥ricas
do sistema.

A tabela templates armazena modelos reutiliz√°veis de arquivos. Cada template
possui um nome √∫nico e um conjunto de arquivos serializados em JSON, permitindo
carregar estruturas prontas de projeto ou c√≥digo.

A tabela config_layout guarda a √∫ltima configura√ß√£o de layout da interface.
Ela registra a ordem dos containers, o tipo de layout, o modo de altura e os
pesos das colunas. Sempre que uma configura√ß√£o √© salva, ela substitui a anterior,
permitindo restaurar o √∫ltimo layout v√°lido ao reiniciar a aplica√ß√£o.

A tabela versoes mant√©m o hist√≥rico de vers√µes instaladas ou utilizadas pelo
sistema. Ela permite identificar a vers√£o atual, listar vers√µes anteriores e
associar informa√ß√µes adicionais a cada vers√£o.

As fun√ß√µes seguem uma separa√ß√£o clara:
‚Äì salvar e carregar templates
‚Äì salvar e carregar configura√ß√£o de layout atual
‚Äì registrar, listar e identificar a √∫ltima vers√£o do sistema

A inicializa√ß√£o do banco √© autom√°tica na importa√ß√£o do m√≥dulo, garantindo que as
tabelas existam antes de qualquer opera√ß√£o.

Em resumo, este m√≥dulo isola predefini√ß√µes, layout da interface e controle de
vers√µes, mantendo esses dados fora do banco operacional principal e facilitando
manuten√ß√£o, restaura√ß√£o de estado e evolu√ß√£o da aplica√ß√£o.

|-- SUB_Traduz_terminal.py ----:
|-- style.css ----:

