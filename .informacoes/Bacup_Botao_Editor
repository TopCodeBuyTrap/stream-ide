import json
import os
import time
from pathlib import Path

from APP_Editores_Auxiliares.EDITOR_Botao import botao_aplica
from Banco_dados import checar_modulos_locais, reset_db, scan_project
from code_editor import code_editor
import streamlit as st
from APP_SUB_Janela_Explorer import Abrir_Arquivo_Select_Tabs
from Banco_dados import gerar_auto_complete_EDITOR, checar_modulos_pip
from APP_SUB_Controle_Driretorios import VENVE_DO_PROJETO, _DIRETORIO_PROJETO_ATUAL_

def_from, def_predefinidos, from_predefinidos = gerar_auto_complete_EDITOR()


def carregar_modulos_venv():
    import sys
    import pkgutil
    _Python_exe, _Root_path, _Venv_path, _Prompt_venv = VENVE_DO_PROJETO()
    site_packages = Path(_Venv_path) / "Lib" / "site-packages"
    sys.path.insert(0, str(site_packages))
    modulos = {}
    for m in pkgutil.iter_modules([str(site_packages)]):
        modulos[m.name] = [m.name]
    for nome, dados in def_predefinidos.items():
        modulos[nome] = os.path.basename(dados["caminho"])
    outras_fontes = [{"nome": "filha", "valor": "isadora"}, {"nome": "amigo", "valor": "joao"}]
    for item in outras_fontes:
        modulos[item["nome"]] = item["valor"]
    return modulos


def Completar(st):
    if "modulos_venv" not in st.session_state:
        st.session_state.modulos_venv = carregar_modulos_venv()
    completions = []
    for nome, origem in st.session_state.modulos_venv.items():
        completions.append({"caption": nome, "value": nome, "meta": origem, "name": nome, "score": 400})
    return completions


_ = st.session_state

# ========================================
# üî• DETEC√á√ÉO IMEDIATA - PRIMEIRA COISA QUE RODA
# ========================================
caminho = Path(r"C:\Users\henri\ProjetoSteamIDE\HENRIQUE\main.py")
nome_arq = os.path.basename(caminho)
aba_id = 42



conteudo_inicial = Abrir_Arquivo_Select_Tabs(st, caminho)
conteudo_inicial_ou_modificado, faltando, logs = checar_modulos_locais(aba_id, conteudo_inicial)

with st.popover(f':material/functions: Minhas Fun√ßoes:'):
    with st.container(border=True, height=200):
        st.code("\n".join(logs), language="bash")
        st.write(faltando)
        st.code(conteudo_inicial_ou_modificado)

# ========================================
editor_key = f"editor_militar_{aba_id}_{nome_arq}"


# ===================== ESTADO =====================
_.setdefault('cursor_pos', {"row": 0, "column": 0})  #

cursor = _["cursor_pos"]
row = cursor.get("row", 0)
col = cursor.get("column", 0)

#--------------------------- O BOTAO SEGUE  na mesma linha
top_px = row * 24
right_px = max(1, 300 - col * 8)

botoes = [{
    "name": "Importar\n".join(faltando),
    "feather": "Smile",

    "hasText": True,
    "text": "Ol√°!",
    "primary": True,
    "commands": ["submit"],
    "style": {
        "top": f"{top_px}px",
        "right": f"{right_px}px"
    }
}]
st.write(True if len(faltando) > 0 else False,)
# Editor CORRIGIDO
codigo = code_editor(
    conteudo_inicial,
    lang='python',
    height='300px',
    shortcuts='vscode',
    completions=Completar(st),
    response_mode=[ "blur"],
    allow_reset=True if len(faltando) > 0 else False,
    buttons=botoes,
    key=editor_key
)


codigo = botao_aplica(st,codigo,f'{"\n".join(conteudo_inicial_ou_modificado)}\n',True)

novo_codigo = codigo.get('text', '') if isinstance(codigo, dict) else str(codigo) if codigo else ""
st.code(f'C√≥digo:\n{novo_codigo}')

# AUTOSAVE MILITAR
if novo_codigo.strip() and novo_codigo != conteudo_inicial_ou_modificado and conteudo_inicial:
    cache_key = f"cache_editor_{aba_id}_{nome_arq}"
    _[cache_key] = novo_codigo
    st.success("üíæ AUTOSAVE: Cache OK")

    try:
        Path(caminho).parent.mkdir(parents=True, exist_ok=True)
        backup_path = Path(caminho).with_suffix('.py.bak')
        if Path(caminho).exists():
            Path(caminho).rename(backup_path)
        Path(caminho).write_text(novo_codigo, encoding='utf-8')
        if backup_path.exists():
            backup_path.unlink()
        _['autosave_status'] = f"üíæ {nome_arq}"
        st.success("üíæ AUTOSAVE: Disco OK")
    except Exception as e:
        emergencia_path = Path(_DIRETORIO_PROJETO_ATUAL_()) / f"EMERGENCIA_{nome_arq}.json"
        emergencia_path.write_text(
            json.dumps({"timestamp": time.time(), "codigo": novo_codigo, "erro": str(e)}, ensure_ascii=False, indent=2),
            encoding='utf-8')
        st.error(f"‚ö†Ô∏è EMERG√äNCIA: {e}")


    # REPROCESSA ANALISE AP√ìS SALVAR
    _, faltando, logs = checar_modulos_locais(
        aba_id,
        novo_codigo
    )
if st.button(f':material/lock_reset:', key=f"botao_restart_alt{aba_id}"):
    reset_db()
    scan_project()  ====  import json

def botao_aplica(st, saida_editor, texto, aplicar_no_topo=False):
    """
    Insere 'texto' no editor.

    aplicar_no_topo = True  -> insere em (0,0)
    aplicar_no_topo = False -> insere na posi√ß√£o atual do cursor
    """

    # üîí Garante que o retorno sempre seja dict v√°lido
    if not isinstance(saida_editor, dict):
        return {"text": str(saida_editor) if saida_editor else ""}

    # Obt√©m posi√ß√£o do cursor enviada pelo editor
    cursor_pos = saida_editor.get("cursor", {"row": 0, "column": 0})

    # Se vier como string JSON, converte
    if isinstance(cursor_pos, str):
        try:
            cursor = json.loads(cursor_pos) if cursor_pos else {}
        except Exception:
            cursor = {}
    elif isinstance(cursor_pos, dict):
        cursor = cursor_pos
    else:
        cursor = {}

    # üî• Define onde vai aplicar o texto
    if aplicar_no_topo:
        row = 0
        col = 0
    else:
        row = cursor.get("row", 0)
        col = cursor.get("column", 0)

    # S√≥ executa se o bot√£o do editor disparar submit
    if saida_editor.get("type") == "submit":

        # Quebra o c√≥digo em linhas
        linhas = saida_editor.get("text", "").split("\n")

        # Garante que a linha exista
        while len(linhas) <= row:
            linhas.append("")

        # Insere o texto na posi√ß√£o escolhida
        linhas[row] = linhas[row][:col] + texto + linhas[row][col:]

        # Junta tudo novamente
        novo_texto = "\n".join(linhas)

        # Atualiza cursor ap√≥s inser√ß√£o
        novo_cursor = {
            "row": row,
            "column": col + len(texto)
        }

        # Atualiza objeto retornado pelo editor
        saida_editor["text"] = novo_texto
        saida_editor["cursor"] = novo_cursor


        return saida_editor

    # Se n√£o for submit, retorna sem alterar
    return saida_editor   Eu estou com um problema aqui no meu c√≥digo, que √© o seguinte. Primeiro eu vou explicar por que que o editor de c√≥digo tem esse... esse Responsimod a√≠ tabular. E ele t√° desse jeito, porque se eu colocar ele pra ficar dando re-run a cada tecla que eu digito, atrapalha aqui meu c√≥digo no StreamLit, entendeu? Ent√£o eu tenho que ficar desse jeito. E esse auto-reset a√≠, eu coloquei uma condi√ß√£o nele, dele ficar true ou false. Porque se ele ficar true, se eu clicar fora do... do editor de c√≥digo, no caso ele salva, mas se eu clicar dentro de novo, ele pega e fica dando Ctrl Z, entendeu? Esse que √© o problema, porque eu estou inserindo um texto via bot√£o e ele s√≥ funciona se o reset tiver true. E se ele tiver falso, ele n√£o funciona. E eu coloquei essa condi√ß√£o e mesmo assim t√° dando esse problema. Ele insere o texto l√° que eu estou mandando e salva, mas se eu clicar dentro dele de novo, ele reseta, entendeu? Ent√£o, t√° canseiro isso a√≠.




    ------------------------------------------
    import json
import os
import time
from pathlib import Path
import streamlit as st
from code_editor import code_editor

# Configura√ß√£o da p√°gina
st.set_page_config(layout="wide")


# ========================================
# üõ†Ô∏è MOCKS E UTILIT√ÅRIOS (Para substituir m√≥dulos locais que faltam)
# ========================================

# Simula o diret√≥rio do projeto
def _DIRETORIO_PROJETO_ATUAL_():
	return os.getcwd()


# Define o arquivo alvo (substituindo o caminho do Windows)
CAMINHO_ARQUIVO = Path("target_file.py")

# Garante que o arquivo existe
if not CAMINHO_ARQUIVO.exists():
	CAMINHO_ARQUIVO.write_text("# Arquivo novo\n", encoding="utf-8")


# ========================================
# üìÇ FUN√á√ïES DE ARQUIVO
# ========================================

def ler_arquivo(caminho):
	try:
		return Path(caminho).read_text(encoding='utf-8')
	except Exception as e:
		st.error(f"Erro ao ler arquivo: {e}")
		return ""


def salvar_arquivo(caminho, conteudo):
	try:
		Path(caminho).write_text(conteudo, encoding='utf-8')
		return True
	except Exception as e:
		st.error(f"Erro ao salvar: {e}")
		return False


# ========================================
# ü§ñ SIMULA√á√ÉO DA FUN√á√ÉO EXTERNA
# ========================================

def add_ao_codigo(codigo_atual):
	"""
	Simula a fun√ß√£o que analisa o c√≥digo e sugere/adiciona algo.
	Neste exemplo, adiciona um import se n√£o existir.
	"""
	import_line = "from outros.modulo_funcao import ler_A_CONTROLE_ABSOLUTO"

	# L√≥gica simples: se o c√≥digo n√£o tiver o import, retorna o import para ser adicionado
	if import_line not in codigo_atual:
		return f"\n{import_line}\n"
	return ""


# ========================================
# üöÄ APLICA√á√ÉO PRINCIPAL
# ========================================

st.title("Editor de C√≥digo Python üêç")

# Inicializa estado se necess√°rio
if 'codigo_atual' not in st.session_state:
	st.session_state['codigo_atual'] = ler_arquivo(CAMINHO_ARQUIVO)
if 'last_save' not in st.session_state:
	st.session_state['last_save'] = 0

conteudo_inicial = st.session_state['codigo_atual']

# Configura√ß√£o dos bot√µes personalizados do editor (opcional)
btn_settings = [{
	"name": "Save",
	"feather": "Save",
	"primary": True,
	"hasText": True,
	"alwaysOn": True,
	"commands": ["save-state", ["response", "saved"]]
}]

# --- COMPONENTE EDITOR ---
# O response_mode='blur' envia o c√≥digo quando o editor perde foco
# Adicionamos bot√µes para permitir salvar explicitamente
response_dict = code_editor(
	conteudo_inicial,
	lang="python",
	height="400px",
	shortcuts="vscode",
	buttons=btn_settings,
	key=f"editor_{CAMINHO_ARQUIVO.name}"
)

# --- PROCESSAMENTO DO RETORNO ---
# O code_editor retorna um dict com 'text' (c√≥digo atual) e 'type' (evento que disparou)

if response_dict:
	novo_codigo = response_dict.get('text', "")
	evento_tipo = response_dict.get('type', "")

	# Se houve altera√ß√£o no texto
	if novo_codigo != st.session_state['codigo_atual']:
		st.session_state['codigo_atual'] = novo_codigo

		# --- AQUI ENTRA A L√ìGICA DE INJE√á√ÉO (add_ao_codigo) ---
		# Exemplo: Injetar automaticamente algo (CUIDADO com loops)
		# Para evitar loops, s√≥ injetamos sob certas condi√ß√µes ou via bot√£o

		# Vamos simular o que voc√™ pediu: "Outro script adiciona ao c√≥digo"
		to_add = add_ao_codigo(novo_codigo)
		if to_add:
			st.info(f"ü§ñ Inje√ß√£o autom√°tica detectada: {to_add.strip()}")
		# Se quiser aplicar automaticamente:
		# novo_codigo += to_add
		# st.session_state['codigo_atual'] = novo_codigo
		# st.rerun() # Recarrega para mostrar o novo c√≥digo no editor

		# --- AUTOSAVE ---
		if novo_codigo.strip():
			salvou = salvar_arquivo(CAMINHO_ARQUIVO, novo_codigo)
			if salvou:
				st.toast(f"üíæ Salvo automaticamente: {CAMINHO_ARQUIVO.name}")
				st.session_state['last_save'] = time.time()

	# Feedback visual
	if evento_tipo == "saved":
		st.success("Salvo manualmente via bot√£o!")

# Exibe o conte√∫do atual para debug
with st.expander("Ver c√≥digo em disco (Read-Only)"):
	st.code(ler_arquivo(CAMINHO_ARQUIVO), language='python')
